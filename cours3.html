<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Informatique Théorique - Hiver 2014</title>

		<meta name="description" content="Informatique Théorique - Hiver 2014">
		<meta name="author" content="Julien Marcil">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/ift.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<script>document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section class="center">
					<h2>IFT-2002</h2>
					<h1>Informatique Théorique</h1>
					<h4>H14 - cours 3</h4>
					<br/>
					<p>
						<small>Julien Marcil - <a href="mailto:julien.marcil@ift.ulaval.ca">julien.marcil@ift.ulaval.ca</a></small>
					</p>
				</section>

				<!--Revision -->

				<section class="center" data-background="#007777">
					<h1 class="title">Cours précédent</h1>
				</section>

				<section>
					<h2>Langage régulier</h2>
					<p>
						<b>Définition:</b>
						Un langage est dit <strong>régulier</strong> s’il existe un automate fini déterministe qui le reconnaît.
					</p>
					<p>
						Une façon de montrer qu’un langage est régulier est de construire un automate qui reconnaît ce langage.
					</p>
				</section>

				<section>
					<h2>Automate fini déterministe</h2>
					<p>
						<b>Définition:</b>
						Un <strong>automate fini déterministe</strong> consiste en un quintuple de la forme $(S, \Sigma, \delta, \iota, F)$ où
						<ul>
							<li>$S$ est un <em>ensemble fini d’états</em>.</li>
							<li>$\Sigma$ est <em>l’alphabet</em>.</li>
							<li>$\delta : S \times \Sigma \to S$ est la <em>fonction de transition</em>.</li>
							<li>$\iota \in S$ est l’<em>état initial</em>.</li>
							<li>$F \subseteq S$ est l’ensemble des <em>états finaux</em> (ou <em>accepteurs</em> ou <em>acceptants</em>).</li>
						</ul>
					</p>
				</section>


				<section>
					<h2>Opérations</h2>
					<p>
						Soit les languages $A$ et $B$. Nous définissons les opérations suivantes:
					</p>
					<p>
						<ul>
							<li><strong>Union</strong>&nbsp;: $A \cup B = \{ x \mid x \in A \ \text{ou} \ x \in B\}$</li>
							<li><strong>Concaténation</strong>&nbsp;: $A \circ B = \{ xy \mid x \in A, \ y \in B\}$</li>
							<li><strong>Étoile</strong>&nbsp;: $A^* = \{ x_1x_2\dots x_k \mid k \ge 0, \ x_i \in A \}$</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>Théorème</h2>
					<p>
						L'ensemble des languages réguliers est fermé sur les opérations: <em>Union</em>, <em>Concaténation</em> et <em>Étoile</em>.
					</p>
				</section>

				<section>
					<h2>Aujourd'hui</h2>
					<ul>
						<li>Automates finis non déterministes</li>
						<li>Expression Régulière</li>
					</ul>
				</section>


				<!-- ************************ Automate non déteministe ************************* -->

				<section class="center" data-background="#007777">
					<h1 class="title">Automates finis non <br>déterministes</h1>
				</section>

				<section>
					<h3>Automate fini non déterministe</h3>
					<p>
						<b>Définition:</b>
						Un <strong>automate fini non déterministe</strong> consiste en un quintuple de la forme $(S, \Sigma, \delta, \iota, F)$ où
						<ul>
							<li>$S$ est un <em>ensemble fini d’états</em>.</li>
							<li>$\Sigma$ est <em>l’alphabet</em>.</li>
							<li>$\delta : S \times \Sigma \to \mathcal P(S)$ est la <em>fonction de transition</em>.</li>
							<li>$\iota \in S$ est l’<em>état initial</em>.</li>
							<li>$F \subseteq S$ est l’ensemble des <em>états finaux</em> (ou <em>accepteurs</em> ou <em>acceptants</em>).</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>$M$ accepte la la séquence $x$</h2>
					<p>
						<b>Définition:</b>
						L’automate fini non déterministe $M = (S, \Sigma, \delta, \iota, F)$ <strong>accepte</strong> (ou <em>reconnaît</em>) la séquence $x = x_1x_2x_3\dots x_n$ (où $s_i \in \Sigma$) si et seulement si il <em>existe</em> une séquence d’états $s_0, s_1, s_2, \dots, s_n$ (où $s_i \in S$) tels que 
						$$\iota = s_0$$
						et $$\forall_{j=1,\dots,n} \ s_j \in \delta(s_{j-1}, x_j)$$
						et $$ s_n \in F $$
					</p>
					<p>
						<small>Dans le cas contraire, on dit que l’automate <strong>rejette</strong> la séquence.</small>
					</p>
				</section>

				<section>
					<h2>Théorème</h2>
					<p>
						Pour tout automate fini non déterministe, il existe un automate fini déterministe qui accepte exactement le même langage.
					</p>
				</section>

				<section>
					<h2>Example</h2>
					<p>Constuire de l’automate fini déterministe équivalent au diagramme de transisition suivant</p>
					<img src="img/nfa5.png" alt="Diagramme de transitions non déterministe">
				</section>

				<section>
					<h2>Remarques</h2>
					<p>
						On n’augmente donc pas la <em>puissance</em> des automates finis en permettant le non déterminisme.
					</p>
					<p>						
						Par conséquent, on peut dire qu’un langage est <em>régulier</em> si il est reconnu par un automate fini non déterministe.
					</p>
					<p>						
						Les automates finis non déterministe ont une représentation plus simple.
					</p>
				</section>

				<section>
					<section>
						<h2>transition sur $\lambda$</h2>
						<p>
							Il est aussi possible de faire des transitions sur $\lambda$. Par example:
						</p>
						<p>
							<img src="img/nfa3.png" alt="Diagramme de transitions non déterministe">
						</p>
					</section>
					<section>
						<h2>Example</h2>
						<p>
							<img src="img/nfa4.png" alt="Diagramme de transitions non déterministe">
						</p>
					</section>
				</section>

				<section>
					<h3>Automate fini non déterministe (avec transition sur $\lambda$)</h3>
					<p>
						<b>Définition:</b>
						Un <strong>automate fini non déterministe</strong> consiste en un quintuple de la forme $(S, \Sigma, \delta, \iota, F)$ où
						<ul>
							<li>$S$ est un <em>ensemble fini d’états</em>.</li>
							<li>$\Sigma$ est <em>l’alphabet</em>.</li>
							<li>$\delta : S \times \Sigma_\lambda \to \mathcal P(S)$ est la <em>fonction de transition</em>.</li>
							<li>$\iota \in S$ est l’<em>état initial</em>.</li>
							<li>$F \subseteq S$ est l’ensemble des <em>états finaux</em> (ou <em>accepteurs</em> ou <em>acceptants</em>).</li>
						</ul>
					</p>
					<p>
						où $\Sigma_\lambda = \Sigma \cup \{\lambda\}$
					</p>
				</section>

				<section>
					<h2>Théorème</h2>
					<p>
						L'ensemble des languages réguliers est fermé sur les opérations: <em>Union</em>, <em>Concaténation</em> et <em>Étoile</em>.
					</p>
				</section>

				<!-- ************************ Expression régulière ************************* -->

				<section class="center" data-background="#007777">
					<h1 class="title">Expression régulière</h1>
				</section>

				<section>
					<h2>Observation</h2>
					<p>
						Soit $L = \{b^mab^n \mid m \in \mathbb N^+, n \in \mathbb N\}$. Il est possible de décomposer $L$ en utilisant les opérations: <em>Union</em>, <em>Concaténation</em> et <em>Étoile</em>.
					</p>
					<p>
						$$ L = \{a\} \circ \{a\}^* \circ \{b\} \circ \{a\}^* $$ 
					</p>
					<p>
						En simplifiant, il est possible d'écrire
					</p>
					<p>
						$$aa^*ba^*$$
					</p>
				</section>

				<section>
					<h2>Expression régulière</h2>
					<p>
						<b>Définition:</b>
						$R$ est une <strong>expression régulière</strong> si $R$ est:
						<ol>
							<li>$a$, pour tout $a \in \Sigma$</li>
							<li>$\lambda$</li>
							<li>$\emptyset$</li>
							<li>$(R_1)$, pour une <em>expression régulière</em> $R_1$</li>
							<li>$R_1 \cup R_2$, pour des <em>expressions régulières</em> $R_1$ et $R_2$</li>
							<li>$R_1 \circ R_2$, pour des <em>expressions régulières</em> $R_1$ et $R_2$</li>
							<li>$R_1^*$, pour une <em>expression régulière</em> $R_1$</li>
						</ol>
					</p>
					<p>
						<small>Note: Cette dénition est de nature récursive.</small>
					</p>
				</section>



				<section>
					<section>				
						<h2>Observation</h2>
						<p>
							L'opération de concaténation est <strong>associative</strong>. Pour tous les langages $L_1$, $L_2$, $L_3$:
						</p>
						<p>
							$$ L_1 \circ (L2 \circ L3) = (L1 \circ L2) \circ L3 $$ 
						</p>
						<p>
							Par conséquent si $r_1$, $r_2$, $r_3$ sont des expressions régulières alors les expressions régulières $r_1 \circ (r_2 \circ r_3)$ et $(r_1 \circ r_2) \circ r_3$ représentent le même langage. 
						</p>
					</section>
					<section>
						<h2>Notation</h2>
						<p>
							Pour alléger la notation, on écrira $r_1r_2$ plutôt que $r_1 \circ r_2$. Donc
						</p>
						<p>
						$$ 
						\begin{align}
							r_1r_2r_3 = &amp; r_1 \circ r_2 \circ r_3 \\
										&amp; r_1 \circ (r_2 \circ r_3) \\
										&amp; (r_1 \circ r_2) \circ r_3 \\
						\end{align}
						$$
						</p>
					</section>
				</section>

				<section>				
					<h2>Observation</h2>
					<p>
						L'opération d'union est <strong>associative</strong>. Pour tous les langages $L_1$, $L_2$, $L_3$:
					</p>
					<p>
						$$ L_1 \cup (L2 \cup L3) = (L1 \cup L2) \cup L3 $$ 
					</p>
					<p>
						Par conséquent si $r_1$, $r_2$, $r_3$ sont des expressions régulières alors les expressions régulières $r_1 \cup (r_2 \cup r_3)$ et $(r_1 \cup r_2) \cup r_3$ représentent le même langage:
					</p>
					<p>
						$$r_1 \cup r_2 \cup r_3$$
					</p>
				</section>

				<section>
					<h2>Règles de priorité</h2>
					<ol>
						<li>
							L'<em>étoile</em> $*$ est prioritaire. C'est à dire que
							$$ 
							\begin{align}
								r_1 \cup r_2^∗  &amp; = r_1 \cup (r_2^∗) \\
								r_1 \circ r_2^∗ &amp; = r_1 \circ (r_2^*)

							\end{align}
							$$
						</li>
						<br/>
						<li>
							La <em>concaténation</em> est prioritaire sur l'<em>union</em>. C'est à dire que
							$$ 
							\begin{align}
								r_1 \cup r_2 \circ r_3 &amp; = r_1 \cup (r_2 \circ r_3) \\
								r_1 \circ r_2 \cup r_3 &amp; = (r_1 \circ r_2) \cup r_3
							\end{align}
							$$
						</li>
					</ol>
				</section>

				<section>
					<h2>Language repésenté par $R$</h2>
					<p>
						<b>Définition:</b>
						Soit une expression régulière $R$ et un alphabet $\Sigma$. Le <strong>language repésenté par $R$</strong> noté $L(R)$, est défini par les propostions récursive suivantes:
						<ol>
							<li>Pour tout $a \in \Sigma$, si $R=a$ alors $L(R) = \{a\}$</li>
							<li>Si $R=\lambda$ alors $L(R) = \{\lambda\}$</li>
							<li>Si $R=\emptyset$ alors $L(R) = \{\}$</li>
							<li>Pour des <em>expressions régulières</em> $R_1$ et $R_2$, si $R = R_1 \cup R_2$, alors $L(R) = L(R_1) \cup L(R_2)$</li>
							<li>Pour des <em>expressions régulières</em> $R_1$ et $R_2$, si $R = R_1 \circ R_2$, alors $L(R) = L(R_1) \circ L(R_2)$</li>
							<li>Pour une <em>expression régulière</em> $R_1$, si $R = R_1^*$, alors $L(R) = L(R_1)^*$</li>
						</ol>
					</p>
				</section>

				<section>
					<h2>Examples</h2>
					<p>
						<table class="examples">
							<tr>
								<td class="regex">$(ab)^*$</td> 	
								<td>représente</td>
								<td class="langage"><p class="fragment roll-in">$\{\lambda, ab, abab, \dots \}$</p></td>
							</tr>
							<tr>
								<td class="regex">$ab^*$</td> 	
								<td>représente</td>	
								<td class="langage"><p class="fragment roll-in">$\{a, ab, abb, abbb, \dots \}$</p></td>
							</tr>
							<tr>
								<td class="regex">$a \cup bc$</td> 	
								<td>représente</td>	
								<td class="langage"><p class="fragment roll-in">$\{a, bc\}$</p></td>
							</tr>
							<tr>
								<td class="regex">$(a \cup b)c$</td> 	
								<td>représente</td>	
								<td class="langage"><p class="fragment roll-in">$\{ac, bc\}$</p></td>
							</tr>
							<tr>
								<td class="regex">$ab \cup bc$</td> 	
								<td>représente</td>	
								<td class="langage"><p class="fragment roll-in">$\{ab, bc\}$</p></td>
							</tr>
							<tr>
								<td class="regex">$a(b \cup b)c$</td> 	
								<td>représente</td>	
								<td class="langage"><p class="fragment roll-in">$\{abc\}$</p></td>
							</tr>
						</table>
					</p>
				</section>

				<section>
					<h2>Examples</h2>
					<p>
						<table class="examples">
							<tr>
								<td class="regex">$(a \cup \lambda)b^*$</td> 	
								<td>représente</td>	
								<td class="langage"><p class="fragment roll-in">$\{ab^n~\text{ou}~b^n \mid n \in \mathbb N \}$</p></td>
							</tr>
							<tr>
								<td class="regex">$(a \cup \lambda)(b \cup \lambda)$</td> 	
								<td>représente</td>	
								<td class="langage"><p class="fragment roll-in">$\{\lambda, a, b, ab\}$</p></td>
							</tr>
							<tr>
								<td class="regex">$a^* \emptyset$</td> 	
								<td>représente</td>	
								<td class="langage"><p class="fragment roll-in">$\{\}$</p></td>
							</tr>
							<tr>
								<td class="regex">$\emptyset^*$</td> 	
								<td>représente</td>	
								<td class="langage"><p class="fragment roll-in">$\{\lambda\}$</p></td>
							</tr>
						</table>
					</p>
				</section>

				<section>
					<section>
						<h2>Théorème</h2>
						<p>
							Soit un alphabet $\Sigma$. Les langages réguliers sur $\Sigma$ sont précisément les langages représentables par les expressions régulières sur $\Sigma$.
						</p>
					</section>
					<section>
						<h2>Démonstration</h2>
						<p>
							La démonstration se divise en deux parties:
							<ul>
								<li>Montrer que tout langage représentable par une expression régulière est régulier.</li>
								<li>Montrer que tout langage régulier est représentable par une expression régulière.</li>
							</ul>
						</p>
					</section>
					<section>
						<h2>Partie 1</h2>
						<p>
							On voit qu’une <em>expression régulière</em> représente toujours un <em>langage régulier</em>, puisque 
							<ul>
								<li>
								les expressions régulières élémentaires représentent des langages réguliers
								</li>
								<li> et que la combinaison d’expressions régulières représentant des langages réguliers est une expression régulière représentant un langage régulier.
								</li>
							</ul>
						</p>
					</section>
				</section>


				<!-- MORE -->


				<section>
					<h2></h2>
					<p>

					</p>
				</section>

				<section>
					<h2></h2>
					<p>
						<b>Définition:</b>

					</p>
				</section>

				<section>
					<section>
						<h2></h2>
						<p>
						</p>
					</section>

					<section>
						<h2>Exemple</h2>
						<p>
						</p>
					</section>
				</section>

				<section>
					<section>
						<h2></h2>
						<p>
						</p>
					</section>

					<section>
						<h2>Exemple</h2>
						<p>
						</p>
					</section>
				</section>

				<section>
					<section>
						<h2></h2>
						<p>
						</p>
					</section>

					<section>
						<h2>Exemple</h2>
						<p>
						</p>
					</section>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: 'ift', // available themes are in /css/theme
				transition: 'linear', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				//parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				//parallaxBackgroundSize: '2100px 900px',
				slideNumber: true,

				math: {
        			mathjax: 'http://cdn.mathjax.org/mathjax/latest/MathJax.js',
        			config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
    			},

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/math/math.js', async: true }
				]
			});

		</script>

	</body>
</html>
