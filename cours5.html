<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Informatique Théorique - Hiver 2014</title>

		<meta name="description" content="Informatique Théorique - Hiver 2014">
		<meta name="author" content="Julien Marcil">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/ift.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<script>document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section class="center">
					<h2>IFT-2002</h2>
					<h1>Informatique Théorique</h1>
					<h4>H14 - cours 5</h4>
					<br/>
					<p>
						<small>Julien Marcil - <a href="mailto:julien.marcil@ift.ulaval.ca">julien.marcil@ift.ulaval.ca</a></small>
					</p>
				</section>

				<!--Revision -->

				<section class="center" data-background="#007777">
					<h1 class="title">Cours précédents</h1>
				</section>

				<section>
					<section>
						<h2>Grammaire</h2>
						<p>
							Une grammaire consiste en un ensemble fini de <strong>règles de réécriture</strong> (ou <em>règles de productions</em> ou <em>règles de substitution</em>).
						</p>
						<p>
							$$ 
							\begin{align}
								S \rightarrow &amp; 0S1 \\
								S \rightarrow &amp; B \\
								B \rightarrow &amp; \lambda 
							\end{align}
							$$
						</p>
					</section>
					<section>
						<h2>Dérivation</h2>
						<p>
							Une grammaire <em>génère</em> une séquence par <strong>dérivation</strong>.
						</p>
						<p>
							$$
							\begin{align}
								S ⇒ &amp; 0S1 \\
								  ⇒ &amp; 00S11 \\
								  ⇒ &amp; 000S111 \\
								  ⇒ &amp; 000B111 \\
								  ⇒ &amp; 000\lambda111 \\
								  ⇒ &amp; 000111
							\end{align}
							$$
						</p>	
					</section>
				</section>

				<section>
					<section>
						<h2>Grammaire</h2>
						<p>
							<b>Définition:</b>
							Une <strong>grammaire</strong> consiste en un quadruplet de la forme $(V, \Sigma, S, R)$ où
							<ul>
								<li>$V$ est ensemble fini de <em>variables</em> (symboles non terminaux).</li>
								<li>$\Sigma$ est <em>l’alphabet</em> (symboles terminaux).</li>
								<li>$S \in V$ est le <em>symbole de départ</em>.</li>
								<li>$R$ est un ensemble fini de <em>règles de réécriture</em>.</li>
							</ul>
						</p>
					</section>
						
					<section>
						<h2>Règles de réécriture</h2>
						<p>
							Ces règles sont formées d’un terme de gauche, d’une flèche ($\rightarrow$) et d’un terme de droite.					
						</p>
						<p>
							Les termes gauche et droit peuvent être n’importe quelle combinaison de symboles de $V$ ou de $\Sigma$, pourvu qu’il y ait au moins un symbole de $V$ à gauche. Le côté droit peut être vide, ce qui est indiqué par un $\lambda$.
						</p>
					</section>
				</section>

				<section>
					<h2>Conventions</h2>
					<p>
						<ul>
							<li>Les majuscules sont des symboles non terminaux.</li>
							<li>Les minuscules sont des symboles terminaux.</li>
							<li>$S$ est le symbole initial.</li>
						</ul>
					</p>
					<p>
						Cette convention permet de simplifier la description d’une grammaire en donnant seulement la description de $R$.
					</p>
				</section>

				<section>
					<h2>Notation</h2>
					<p>
						$$
							\begin{align}
							 	S &amp; \rightarrow ASC &amp;
								S &amp; \rightarrow B \\
								B &amp; \rightarrow bB &amp;
								B &amp; \rightarrow \lambda \\
								A &amp; \rightarrow a &amp;
								C &amp; \rightarrow c \
							\end{align}
							$$
					</p>
					<p>
						Il est possible de noté les règles de réécriture plus simplement
					</p>
					<p>
						$$
							\begin{align}
							 	S &amp; \rightarrow ASC \mid B \\
								B &amp; \rightarrow bB \mid \lambda \\
								A &amp; \rightarrow a \\
								C &amp; \rightarrow c \
							\end{align}
							$$
					</p>
				</section>

				<section>
					<h2>Production</h2>
					<p>
						On nomme <strong>production</strong> l'application d'une régle de de réécriture à une chaîne de symboles terminaux et non terminaux.
					</p>
					<p>
						Soit $u, v, w \in (V \cup \Sigma)^*$, et la régle de de réécriture $A \rightarrow w$.
						On dit que $uAv$ <em>produit</em> $uwv$, noté
					</p>
					<p>
						$$uAv \Rightarrow uwv$$
					</p>
				</section>

				<section>
					<h2>Dérivation</h2>
					<p>
						On nomme <strong>dérivation</strong> l'application d'une ou plusieurs régles de de réécriture à une chaîne de symboles terminaux et non terminaux.
					</p>
					<p>
						Soit $u, v \in (V \cup \Sigma)^*$ on dit $u$ <em>dérive</em> $v$, noté 
						$$ u \overset{*}{\Rightarrow} v $$
					</p>
					<p>
						si $u = v$ ou s'il existe $u_1,u_2,...,u_k$ pour $k \ge 0$ et
					</p>
					<p>
						$$u⇒u1 ⇒u2 ⇒...⇒uk ⇒v$$
					</p>
				</section>

				<section>
					<h2>Langage généré par $G$</h2>
					<p>
						Soit la gramaire $G = (V, \Sigma, S, R)$.
					</p>
					<p>
						$$L(G) = \{ w \in Σ^* \mid S \overset{*}{\Rightarrow} w \}$$
					</p>
					<p>
						On dit que $L(G)$ est le <strong>langage généré par $G$</strong>.
					</p>
				</section>

				<section>
					<h2>Aujourd'hui</h2>
					<ul>
						<li>Grammaire</li>
						<ul>
							<li>régulière</li>
							<li>hors context</li>
						</ul>
						<li>Automate à pile</li>
					</ul>
				</section>

				<section class="center" data-background="#007777">
					<h1 class="title">Grammaire</h1>
				</section>

				<section>
					<section>
						<h2>Grammaire régulière</h2>
						<p>
							<b>Définition:</b>
							Soit $G = (V, \Sigma, S, R)$ une grammaire. $G$ est <strong>régulière</strong> si
							les <em>règles de réécriture</em> respecte les restrictions suivantes:
							<ul>
								<li>
									Les termes de gauche consistent en un seul symbole <em>non terminal</em>.
								</li>
								<li>
									Les termes de droit consistent en soit
									<ul>
										<li>un symbole <em>terminal</em> suivi d’un symbole <em>non terminal</em></li>
										<li>un seul symbole <em>terminal</em></li>
										<li>$\lambda$</li>
									</ul>
								</li>
							</ul>
						</p>
					</section>
					<section>
						<h2>Exemple</h2>
						<p>
							$$
							\begin{align}
							 	S &amp; \rightarrow bS &amp;
								S &amp; \rightarrow a &amp;
								S &amp; \rightarrow \lambda
							\end{align}
							$$
						</p>
					</section>
					<section>
						<h2>Remarque</h2>
						<p>
							À cause de ces restrictions, une grammaire régulière permet de générer les symboles de gauche à droite. 
						</p>
						<p>
							Après $k$ applications de règles de production qui ne sont pas des $\lambda$-règles le mot généré est de la forme 
						</p>
						<p>
							$$a_1a_2...a_kA$$
						</p>
						<p>
							où $a_i \in \Sigma$ et $A \in V$
						</p>
					</section>
				</section>

				<section>
					<h2>Théorème</h2>
					<p>
						Soit $G$ une grammaire.
					</p>
					<p>
						$$L(G) \text{ est régulier } \Longleftrightarrow G \text{ est régulière }$$
					</p>
				</section>

				<section>
					<section>
						<h2>Grammaire hors contexte</h2>
						<p>
							<b>Définition:</b>
							Soit $G = (V, \Sigma, S, R)$ une grammaire. $G$ est <strong>hors contexte</strong> si
							les <em>règles de réécriture</em> respecte les restrictions suivantes:
							<ul>
								<li>
									Les termes de gauche consistent en un seul symbole <em>non terminal</em>.
								</li>
							</ul>
						</p>
					</section>

					<section>
						<h2>Exemple</h2>
						<p>
							$$
							\begin{align}
							 	S &amp; \rightarrow SS &amp;
								S &amp; \rightarrow aSb \\
								S &amp; \rightarrow \lambda
							\end{align}
							$$
						</p>
					</section>
				</section>
	
				<section>
					<section>
						<h2>Grammaire hors contexte</h2>
						<p>
							Ce type de grammaire est le plus utilisé en informatique.
						</p>
						<p>
							Les grammaires BNF (Backus-Naur Form), utilisées pour définir la syntaxe des langages de programmation, sont des grammaires équivalentes aux grammaires non contextuelles.
						</p>
					</section>
					
					<section>
						<h2>grammaires BNF</h2>
						<pre><code data-trim>
&lt;expr&gt; ::= &lt;term&gt; "+" &lt;expr&gt;
        |  &lt;term&gt;

&lt;term&gt; ::= &lt;factor&gt; "*" &lt;term&gt;
        |  &lt;factor&gt;

&lt;factor&gt; ::= "(" &lt;expr&gt; ")"
          |  &lt;const&gt;

&lt;const&gt; ::= integer
						</code></pre>
					</section>
				</section>

				<section>
					<h2>Remarques</h2>
					<p>
						Les grammaires non contextuelles génèrent des chaînes par dérivation tout comme les grammaires régulières.
					</p>
					<p>
						Mais dans le cas des grammaires non contextuelles, au cours du processus de dérivation, la possibilité peut s’offrir à nous de choisir parmi plusieurs non terminaux à remplacer.
					</p>
				</section>

				<section>
					<h2>Exemple</h2>
					<p>
						$$
						\begin{align}
						 	S \to &amp; zMNz \\
							M \to &amp; aMa \mid z \\
							N \to &amp; bNB \mid z
						\end{align}
						$$
					</p>
					<p>
						$$ S \overset{*}{\Rightarrow} zazabzbz$$
					</p>
				</section>

				<section>
					<section>
						<h2>Dérivation à gauche</h2>
						<p>
							Une <strong>dérivation à gauche</strong> s’effectue en remplaçant toujours, à chaque étape du processus de dérivation, le non terminal le plus à gauche.
						</p>
					</section>
					<section>
						<h2>Dérivation à droite</h2>
						<p>
							Une <strong>dérivation à droite</strong> s’effectue en remplaçant toujours, à chaque étape du processus de dérivation, le non terminal le plus à droite.
						</p>
					</section>
				</section>

				<section>
					<h2>Arbre de dérivation</h2>
					<p>
						La racine de l’arbre de dérivation est l’axiome de la grammaire.
					</p>
					<p>
						Les non terminaux forment les nœuds internes et les terminaux forment les feuilles.
					</p>
				</section>

				<section>
					<h2>Exemple</h2>
					<p>
						$$
						\begin{align}
						 	S \to &amp; S + S \\
							S \to &amp; S * S \\
							S \to &amp; ( S ) \\
							S \to &amp; S - S \\
							S \to &amp; S \ / \ S \\
							S \to &amp; a
						\end{align}
						$$
					</p>
					<p class="fragment roll-in">
						$$ S \overset{*}{\Rightarrow} a+a*a$$
					</p>
				</section>

				<section>
					<h2>grammaire ambiguë</h2>
					<p>
						Une grammaire est dite <strong>ambiguë</strong> si elle permet plus d’un arbre de dérivation pour une séquence terminale donnée.
					</p>
				</section>

				<section>
					<h2>Langage hors contexte</h2>
					<p>
						<b>Définition:</b>
						Un langage est dit <strong>hors contexte</strong> (ou <em>non contextuelle</em>) s’il existe une grammaire hors contexte qui le génère.
					</p>
				</section>

				<section>
					<section>
						<h2>Forme normale de Chomsky</h2>
						<p>
							<b>Définition:</b>
							Soit $G = (V, \Sigma, S, R)$ une grammaire. $G$ est dans la <strong>forme normale de Chomsky</strong> si
							les <em>règles de réécriture</em> sont de la forme:
							<ul>
								<li>
									$A \to BC$ pour $A, B, C \in V$ et $B \ne S$ et $C \ne S$
								</li>
								<li>
									$A \to a$ pour $A \in V$, $a \in \Sigma$.
								</li>
								<li>
									$S \to \lambda$ pour le <em>symbole de départ</em> $S$.
								</li>
							</ul>
						</p>
					</section>

					<section>
						<h2>Noam Chomsky</h2>
						<div class="pull-right">
							<img src="img/Chomsky.jpg" alt="Noam Chomsky">
						</div>
						<p>
							<a href="http://fr.wikipedia.org/wiki/Noam_Chomsky">Noam Chomsky</a> est un linguiste et philosophe américain. Professeur émérite de linguistique au Massachusetts Institute of Technology où il a enseigné toute sa carrière, il a fondé la linguistique générative. Il s'est fait connaître du grand public, à la fois dans son pays et à l'étranger, par son parcours d'intellectuel engagé de sensibilité anarchiste.
						</p>
					</section>
				</section>

				<section>
					<section>
						<h2>Théorème</h2>
						<p>
							Tout langage <em>hors contexte</em> est généré par une grammaire dans la <em>forme normale de Chomsky</em>.
						</p>
					</section>
					<section>
						<h2>Transformation</h2>
						<p>
							Il est possible de transformer un grammaire <em>hors context</em> en grammaire dans la <em>forme normale de Chomsky</em>.
						</p>
						<p>
							<ol>
								<li>Ajouter une variable $S_0$</li>
								<li>Remplacer les règles-$\lambda$</li>
								<li>Remplacer les règles unitaires</li>
								<li>Ajouter des variables pour les règles trop longue</li>
							<ol>
						</p>
					</section>
				</section>

				<!-- **************************************************************************************** -->

				<section class="center" data-background="#007777">
					<h1 class="title">Automate à pile</h1>
				</section>

				<section>
					<h2>Introduction</h2>
					<p>
						Pour augmenter la puissance des automates finis, on leur donne de la mémoire en leur ajoutant une <strong>pile</strong>.
					</p>
				</section>

				<section>
					<h2>Alphabet de la pile</h2>
					<p>
						La pile de l’automate à pile a son propre alphabet qui peut être différent de l’alphabet d’entrée.
					</p>
				</section>

				<section>
					<h2>Automate à pile</h2>
					<p>
						<b>Définition:</b>
						Un <strong>automate à pile</strong> consiste en un sixtuplet de la forme $(S, \Sigma, \Gamma, \delta, \iota, F)$ où
						<ul>
							<li>$S$ est un ensemble fini d’états.</li>
							<li>$\Sigma$ est l’alphabet d’entrée (alphabet du ruban).</li>
							<li>$\Gamma$ est l’alphabet de la pile.</li>
							<li>$\delta : S \times \Sigma_\lambda \times \Gamma_\lambda \to \mathcal P(S \times \Sigma_\lambda)$ est la <em>fonction de transition</em>.</li>
							<li>$\iota \in S$ est l’<em>état initial</em>.</li>
							<li>$F \subseteq S$ est l’ensemble des <em>états finaux</em> (ou <em>accepteurs</em> ou <em>acceptants</em>).</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>Opérations</h2>
					<p>
						Les opérations que peut effectuer un automate à pile sont les suivantes:
						<ul>
							<li>Lire un symbole (et avancer la tête de lecture)</li>
							<li>Dépiler un symbole</li>
							<li>Empiler un symbole</li>
							<li>Changer d’état</li>
						</ul>
					</p>
					<p>
						Le choix d’opération dépend de l’état courant, du symbole lu sur le ruban d’entrée et du symbole apparaissant sur le dessus de la pile. 
					</p>
				</section>

				<section>
					<section>
						<h2>Transition</h2>
						<p>
							On décrit une transtion de l'automate à pile par 
						</p>
						<p>
							$$p, x, y \to q, z$$
						</p>
						<p>
							<ul>
								<li>$p$ l'état courant</li>
								<li>$x$ est le symbole à l’entrée</li>
								<li>$y$ est le symbole dépilé</li>
								<li>$q$ est le nouvel état</li>
								<li>$z$ est le symbole empilé</li>
							</ul>
						</p>

					</section>	
					<section>
						<h2>Remarques</h2>
						<p>
							<ul>
								<li>Le $y$ est dépilé avant que le $z$ ne soit empilé.</li>
								<li>Si aucun symbole n’est lu, on met un $\lambda$ à la place du $x$.</li>
								<li>Si aucun symbole n’est dépilé, on met un $\lambda$ à la place du $y$.</li> 
								<li>Si aucun symbole n’est empilé, on met un $\lambda$ à la place du $z$.</li>
							</ul>
						</p>
					</section>
				</section>
				
				<section>
					<h2>Exemple</h2>
					<p>
						Soit l'automate à pile suivant $M = (S, \Sigma, \Gamma, \delta, \iota, F)$ tel que
					</p>
					<p>
					$$
					\begin{align}
						S = &amp; \{s_1, s_2, s_3, s_4 \} \\
						\Sigma = &amp; \{0, 1 \} \\
						\Gamma = &amp; \{0, $ \} \\
						\iota = &amp; s_1 \\
						F =  &amp; \{s_1, s_4 \}
					\end{align}
					$$
					</p>
					<p>
					$$ 
					\begin{align}
					\delta = \{ &amp; (s_1, \lambda, \lambda \to s_2, $), (s_2, 0, \lambda \to s_2, 0), \\
								&amp; (s_2, 1, 0 \to s_3, \lambda), (s_3, 1, 0 \to s_3, \lambda), \\
								&amp; (s_3, \lambda, $ \to s_4, \lambda) \} 
					\end{align}					
					$$
					</p>
				</section>

				<section>
					<h2>Diagrame de transitions</h2>
					<p>
						Les diagrammes de transitions des automates à pile sont comme ceux des automates finis sauf que l’étiquette d’un arc est plus complexe.
					</p>
					<p>
						Ces étiquettes ont la forme $x, y \to z$, où 
						<ul>
							<li>$x$ est le symbole lu sur le ruban,</li>
							<li>$y$ est le symbole dépilé et</li>	
							<li>$z$ est le symbole empilé.</li>
						</ul>
					</p>
				</section>

				<section>
					<h2>Exemple</h2>
					<p>
						<img src="img/pda1.png" alt="Diagrammes de transitions">
					</p>
				</section>

				<section>
					<section>
						<h2>Exercice</h2>
						<p>
							Donner un automate à pile qui accepte $L= \{ ww^R \mid w \in \{0,1\}^* \}$.
						</p>
					</section>
					<section>
						<h2>Exercice</h2>
						<p>
							Donner un automate à pile qui accepte $L= \{a^ib^jc^k \mid i,j,k ≥ 0 \text{ et } i = j \text{ ou } i = k \}$.
						</p>
					</section>
				</section>

				<section>
					<h2>Théorème</h2>
					<p>
						Soit $M = (S, \Lambda, \Gamma, \delta, \iota, F)$ un automate à pile qui peut accepter des séquences sans vider sa pile. Il existe un automate à pile $M' = (S', \Lambda', \Gamma', \delta', \iota', F')$ qui vide toujours sa pile avant d’accepter et tel que $L(M) = L(M')$.
					</p>
				</section>

				<section>
					<h2>Théorème</h2>
					<p>
						$L$ est un language <em>hors context</em> si et seulement si un automate à pile accepte $L$.
					</p>
				</section>

				<!-- **************************************************************************************** -->

				<section class="center" data-background="#007777">
					<h1 class="title">...</h1>
				</section>

				<section>
					<h2></h2>
					<p>
					</p>
				</section>

				<section>
					<section>
						<h2></h2>
						<p>
						</p>
					</section>

					<section>
						<h2>Exemple</h2>
						<p>
						</p>
					</section>
				</section>

				<section>
					<section>
						<h2></h2>
						<p>
						</p>
					</section>

					<section>
						<h2>Exemple</h2>
						<p>
						</p>
					</section>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: 'ift', // available themes are in /css/theme
				transition: 'linear', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				//parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				//parallaxBackgroundSize: '2100px 900px',
				slideNumber: true,

				math: {
        			mathjax: 'http://cdn.mathjax.org/mathjax/latest/MathJax.js',
        			config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
    			},

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/math/math.js', async: true }
				]
			});

		</script>

	</body>
</html>
